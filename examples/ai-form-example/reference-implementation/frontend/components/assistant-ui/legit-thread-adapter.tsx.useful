


import {
  useLocalThreadRuntime,
  unstable_useRemoteThreadListRuntime as useRemoteThreadListRuntime,
  useThreadListItem,
  RuntimeAdapterProvider,
  AssistantRuntimeProvider,
  type unstable_RemoteThreadListAdapter as RemoteThreadListAdapter,
  type ThreadHistoryAdapter,
} from '@assistant-ui/react';

import { useDataStreamRuntime } from '@assistant-ui/react-data-stream';
import { useMemo } from 'react';
type RemoteThreadListrespone = Awaited<
  ReturnType<RemoteThreadListAdapter['list']>
>;

const model = new DataStreamRuntimeAdapter

// Implement your custom adapter with proper message persistence
const legitThreadAdapter: RemoteThreadListAdapter = {
  async list() {
    const response: RemoteThreadListrespone = {
      threads: [],
    };
    if (!(typeof window !== 'undefined' && window.electronAPI)) {
      console.warn('not in an electron window');
      return response;
    }

    const state = (await window.electronAPI.getAppState()) as any;

    if (state.settings.path === undefined) {
      console.log('no path set yet');
      return response;
    }
    try {
      // TODO use .legit/branches instead - when the settings is set correctly
      const dirPath = `${state.settings.path}/.legit/branches`;
      const branchFolders = (await window.electronAPI.readDir(
        dirPath
      )) as string[];
      console.log('Branch files:', branchFolders);

      for (const branchName of branchFolders) {
        if (
          !branchName.startsWith('legit-thread-') ||
          branchName.endsWith('-operation')
        ) {
          continue;
        }

        response.threads.push({
          remoteId: branchName,
          title: branchName as string,
          status: 'regular',
        });
      }
    } catch (err) {
      console.error('Failed to read branches directory:', err);
    }

    return response;
  },

  async initialize(threadId) {
    if (!(typeof window !== 'undefined' && window.electronAPI)) {
      throw new Error('not in an electron window');
    }

    const state = (await window.electronAPI.getAppState()) as any;

    if (state.settings.path === undefined) {
      console.log('no path set yet');
      throw new Error('no path set yet');
    }
    try {
      // TODO use .legit/branches instead - when the settings is set correctly
      const newBranchPath = `${state.settings.path}/.legit/branches/${threadId}`;
      await window.electronAPI.mkdir(newBranchPath);
    } catch (err) {
      console.error('Failed to read branches directory:', err);
      throw err;
    }
    return { remoteId: threadId, externalId: undefined };
  },

  async rename(remoteId, newTitle) {
    console.log('Renaming thread not implemented');
  },

  async archive(remoteId) {
    console.log('Archiving thread not implemented');
  },

  async unarchive(remoteId) {
    console.log('Unarchiving thread not implemented');
  },

  async delete(remoteId) {
    // Delete thread and its messages
    // await db.messages.deleteByThreadId(remoteId);
    // await db.threads.delete(remoteId);
    console.log('Deleting thread not implemented');
  },

  async generateTitle(remoteId, messages) {
    // Generate title from messages using your AI
    const newTitle = remoteId; // await generateTitle(messages);

    // Persist the title in your DB
    // await db.threads.update(remoteId, { title: newTitle });

    // IMPORTANT: Return an AssistantStream so the UI updates
    return createAssistantStream(controller => {
      controller.appendText(newTitle);
      controller.close();
    });
  },
};

// Complete implementation with message persistence using Provider pattern
export function LegitRuntimeProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  const runtime = useRemoteThreadListRuntime({
    runtimeHook: () => {
      // Use minimal defaultChatModelAdapter, options from closure
      return useLocalThreadRuntime(defaultChatModelAdapter, {});
    },
    adapter: {
      ...legitThreadAdapter,

      unstable_Provider: ({ children }) => {
        const threadListItem = useThreadListItem();
        const remoteId = threadListItem.remoteId;
        const history = useMemo<ThreadHistoryAdapter>(
          () => ({
            async load() {
              if (!remoteId) return { messages: [] };

              //   const messages = await db.messages.findByThreadId(remoteId);
              return {
                messages: [],
                // messages.map(m => ({
                //   role: m.role,
                //   content: m.content,
                //   id: m.id,
                //   createdAt: new Date(m.createdAt),
                // })),
              };
            },
            async append(message) {
              if (!remoteId) {
                console.warn('Cannot save message - thread not initialized');
                return;
              }

              //   await db.messages.create({
              //     threadId: remoteId,
              //     role: message.role,
              //     content: message.content,
              //     id: message.id,
              //     createdAt: message.createdAt,
              //   });
            },
          }),
          [remoteId]
        );
        const adapters = useMemo(() => ({ history }), [history]);
        return (
          <RuntimeAdapterProvider adapters={adapters}>
            {children}
          </RuntimeAdapterProvider>
        );
      },
    },
  });

  return (
    <AssistantRuntimeProvider runtime={runtime}>
      {children}
    </AssistantRuntimeProvider>
  );
}
